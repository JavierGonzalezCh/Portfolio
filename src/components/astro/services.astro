---
import { Server, Cpu, Network } from "lucide-react";
import type { Content } from "../../types";

interface Props {
  content: Content;
}

const { content } = Astro.props;

// Mapeo de iconos (Igual que en React, funciona nativo en el build)
const iconMap = {
  architecture: Server,
  performance: Cpu,
  integration: Network,
};
---

<section
  id="services"
  class="py-32 px-6 relative z-10 bg-gradient-to-b from-tech-blue-primary to-tech-gray-charcoal"
>
  <div class="max-w-7xl mx-auto">
    <div
      class="flex flex-col md:flex-row justify-between items-end mb-20 gap-8"
    >
      <h2
        class="reveal-text text-4xl md:text-6xl font-serif max-w-xl text-tech-text-primary"
      >
        {content.expertise.title}
      </h2>
      <p
        class="reveal-text delay-200 text-tech-text-secondary max-w-md text-lg text-right"
      >
        {content.expertise.subtitle}
      </p>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
      {
        content.expertise.items.map((item, index) => {
          const Icon = iconMap[item.icon as keyof typeof iconMap];

          // Calculamos un delay escalonado para la animación (stagger)
          // index * 100ms
          const delayClass = `delay-${index * 100}`;

          return (
            <article class="group relative bg-tech-gray-card rounded-xl overflow-hidden transition-all duration-300 hover:-translate-y-1">
              <div class="absolute -inset-0.5 bg-linear-to-r from-tech-gold to-tech-blue-secondary opacity-0 group-hover:opacity-30 blur-md transition duration-500 group-hover:duration-200" />

              <div class="relative h-full bg-tech-gray-card p-8 rounded-xl ring-1 ring-white/10">
                <Icon size={28} />
              </div>

              <h3 class="text-2xl font-bold mb-4 text-tech-text-primary">
                {item.title}
              </h3>
              <p class="text-tech-text-secondary leading-relaxed mb-8 flex-1">
                {item.description}
              </p>

              <div class="border-t border-tech-blue-secondary/30 pt-6">
                <div class="flex flex-wrap gap-2">
                  {item.techList.map((tech) => (
                    <span class="text-xs font-mono text-tech-gold/80 bg-tech-gold/5 border border-tech-gold/20 px-2 py-1 rounded">
                      {tech}
                    </span>
                  ))}
                </div>
              </div>
            </article>
          );
        })
      }
    </div>
  </div>
</section>

<script>
  // Script minimalista para detectar scroll y animar
  // Esto reemplaza a "whileInView" de Framer Motion
  const observerOptions = {
    root: null,
    rootMargin: "0px",
    threshold: 0.1, // Se activa cuando el 10% del elemento es visible
  };

  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target.classList.add("is-visible");
        observer.unobserve(entry.target); // Dejar de observar una vez animado
      }
    });
  }, observerOptions);

  // Observamos títulos y tarjetas
  document.querySelectorAll(".reveal-text, .reveal-card").forEach((el) => {
    observer.observe(el);
  });
</script>

<style>
  /* ESTILOS DE ANIMACIÓN */

  /* Estado inicial: invisible y desplazado hacia abajo */
  .reveal-text,
  .reveal-card {
    opacity: 0;
    transform: translateY(30px);
    transition: all 0.8s cubic-bezier(0.17, 0.55, 0.55, 1); /* Easing suave */
  }

  /* Estado final: visible y en su lugar */
  .reveal-text.is-visible,
  .reveal-card.is-visible {
    opacity: 1;
    transform: translateY(0);
  }

  /* Delays utilitarios (Stagger effect) */
  .delay-100 {
    transition-delay: 100ms;
  }
  .delay-200 {
    transition-delay: 200ms;
  }
  .delay-300 {
    transition-delay: 300ms;
  }
</style>
